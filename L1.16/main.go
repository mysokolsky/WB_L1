// L1.16
// Быстрая сортировка (quicksort)
// Реализовать алгоритм быстрой сортировки массива
// встроенными средствами языка. Можно использовать рекурсию.

// Подсказка: напишите функцию quickSort([]int) []int которая сортирует срез целых чисел.
// Для выбора опорного элемента можно взять середину или первый элемент.

// Дедлайн — 6 нояб, 02:59

// Решение:
//
// Берём элементы крайний левый, крайний правый и в середине массива
// Упорядочиваем их, меняя местами по возрастанию.
// Выбираем средний в качестве значения pivot для сравнения всех остальных элементов с ним.
// Идём в цикле с левого края вправо по каждому элементу, пропуская все что <= pivot
// Находим первый элемент что > pivot. Запоминаем его индекс.
// Идём в цикле с правого края влево по каждому элементу, пропуская все что >= pivot
// Находим первый элемент что < pivot. Запоминаем его индекс.
// Если запомненный индекс левого элемента < запомненного индекса правого, меняем элементы местами
// Продолжаем пока левый скан не пересечётся с правым сканом
// Логически разделяем массив на 2 подмассива в точке пересечения сканов
// Рекурсивно выполняем предыдущие операции с левым и правым подмассивами
//
// По хорошему, нужно было бы сделать обработку левой и правой частей через горутины.

package main

import "fmt"
import "github.com/mysokolsky/WB_L1/utils" // необходимо загрузить утилиты в консоли из папки проекта командой go get github.com/mysokolsky/WB_L1/utils

func quickSort(mas []int) []int {
	if err := utils.QuickSort(mas, 0, len(mas)-1); err != nil {
		fmt.Println(err)
	}
	return mas
}

func main() {

	var mas = []int{1, 5, 33, 9, 0, -1, 0, 4, -7, 2, 5, 23, -99, 1000, -6, 3}

	fmt.Printf("\nМассив до сортировки:\n%+v\n", mas)
	fmt.Printf("\nРезультат сортировки:\n%+v\n", quickSort(mas))
}
