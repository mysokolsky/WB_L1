// L1.16
// Быстрая сортировка (quicksort)
// Реализовать алгоритм быстрой сортировки массива
// встроенными средствами языка. Можно использовать рекурсию.

// Подсказка: напишите функцию quickSort([]int) []int которая сортирует срез целых чисел.
// Для выбора опорного элемента можно взять середину или первый элемент.

// Дедлайн — 6 нояб, 02:59

// Решение:
//
// Берём элемент в середине массива
// проходим по всем остальным элементам
// все элементы, что < нашего, кладём влево, которые > кладём вправо от нашего
// Далее рекурсивно делаем с левой и правой частями то же самое
//
// Что верно
// Выбор опорного элемента: Вы можете взять элемент в середине массива (или первый, последний, случайный). Это называется опорным элементом, или «пивотом».
// Разделение: Вы правильно описываете, что элементы, которые меньше опорного, перемещаются влево, а те, что больше — вправо.
// Рекурсия: Алгоритм рекурсивно применяется к двум подмассивам — слева и справа от опорного элемента.
// Важный нюанс: как происходит разделение
// Вы упустили деталь, которая делает быструю сортировку эффективной: это не просто «взять и положить» в новый массив. На самом деле, разделение (partitioning) происходит «на месте» (in-place), без использования дополнительной памяти.
// Один из распространённых способов (алгоритм Хоара):
// Выбирается опорный элемент (например, в середине).
// Создаются два указателя: один на начало массива (левый), другой — на конец (правый).
// Левый указатель движется вправо, пока не найдёт элемент, который больше опорного.
// Правый указатель движется влево, пока не найдёт элемент, который меньше опорного.
// Если указатели не встретились, элементы, на которые они указывают, меняются местами.
// Процесс повторяется, пока указатели не встретятся. В результате опорный элемент оказывается на своей окончательной позиции, а массив оказывается разделён на две части.
// Таким образом, ваше описание корректно на высоком уровне, но не отражает эффективную реализацию разделения, которая лежит в основе алгоритма Quicksort.

package main

import "fmt"

var counter = 0
var atom = 0

func Median(mas []int, left, right int) int {
	center := (left + right) / 2
	if mas[left] > mas[center] {
		mas[left], mas[center] = mas[center], mas[left]
	}
	if mas[center] > mas[right] {
		mas[right], mas[center] = mas[center], mas[right]
	}
	if mas[left] > mas[center] {
		mas[left], mas[center] = mas[center], mas[left]
	}
	pivot := mas[center]
	return pivot
}

// используем для сортировки алгоритм Хоара
func Sort(mas []int, left, right int) error {
	if left > right {
		return fmt.Errorf("Неверные границы массива")
	}

	atom++

	fmt.Printf(">>>>>> %v <<<<<<<\n", atom)

	defer func() {
		fmt.Printf("---------- Выход из цикла рекурсии %v -----------\n", counter)
		counter--
	}()
	counter++
	fmt.Printf("---------- Вход  в  цикл  рекурсии %v -----------\n", counter)

	fmt.Println("Левая граница left = ", left)
	fmt.Println("Правая граница right = ", right)
	fmt.Printf("Массив для упорядочивания\n%+v\n", mas[left:right+1])

	if right-left < 2 {
		if right-left == 1 {
			if mas[left] > mas[right] {
				mas[left], mas[right] = mas[right], mas[left]
			}
		}
		return nil
	}

	pivot := Median(mas, left, right)
	fmt.Printf("Массив после медианы\n%+v\n", mas[left:right+1])

	if right-left == 2 {
		return nil
	}

	fmt.Println("pivot = ", pivot)

	i := left
	j := right

	for i <= j {

		fmt.Printf("i = %v, j = %v\n", i, j)

		for mas[i] < pivot {
			i++
		}
		for mas[j] > pivot {
			j--
		}
		if i <= j {

			fmt.Printf("Меняем элементы по индексам i = %v, j = %v\n", i, j)

			mas[i], mas[j] = mas[j], mas[i]
			i++
			j--
			fmt.Printf("Массив с переставленными элементами:\n%+v\n", mas[left:right+1])
		}
		fmt.Scanln()
	}

	fmt.Printf("i = %v, j = %v\n", i, j)
	fmt.Println("Рекурсия")

	if left < j {
		fmt.Println("Сортировка левой части. Индексы:", left, "-", j)
		fmt.Printf("Массив для сортировки:\n%+v\n", mas[left:j+1])
		Sort(mas, left, j)
	}

	if i < right {
		fmt.Println("Сортировка правой части. Индексы:", i, "-", right)
		fmt.Printf("Массив для сортировки:\n%+v\n", mas[i:right+1])
		Sort(mas, i, right)
	}
	return nil
}

func quickSort(mas []int) []int {
	if err := Sort(mas, 0, len(mas)-1); err != nil {
		fmt.Println(err)
	}
	return mas
}

func main() {

	var mas = []int{1, 5, 33, 9, 0, -1, 0, 4, -7, 2, 5, 23, -99, 1000, -6, 3}

	fmt.Printf("%+v\n", mas)
	fmt.Printf("%+v\n", quickSort(mas))
}
