// L1.26
// Уникальные символы в строке
// Разработать программу, которая проверяет, что все символы
// в строке встречаются один раз (т.е. строка состоит из уникальных символов).

// Вывод: true, если все символы уникальны, false, если есть повторения.
// Проверка должна быть регистронезависимой, т.е. символы в разных регистрах считать одинаковыми.

// Например: "abcd" -> true, "abCdefAaf" -> false (повторяются a/A), "aabcd" -> false.

// Подумайте, какой структурой данных удобно воспользоваться для проверки условия.

// Дедлайн — 20 дек, 02:59
// Решение:

package main

import "strings"
import "fmt"

func IsUniqueSymbols(str string) bool {
	// сначала делаем копию строки только прописных символов, а после конвертируем строку в слайс рун
	editLowerStr := []rune(strings.ToLower(str))

	// создаём мапу для хранения уникальных ключей-символов.
	// Значения нам не нужны, поэтому их делаем пустыми типа struct{}. По сути это тип set
	m := make(map[rune]struct{}, len(editLowerStr))

	// делаем обход слайса
	for _, value := range editLowerStr {

		// проверяем существование такого символа в виде ключа в мапе
		_, ok := m[value]

		// при встрече символа, который уже есть в мапе, выходим
		if ok {
			return false
		}
		m[value] = struct{}{} // заносим неповторяющиеся символы ключами в мапу
	}
	return true
}

func main() {

	strs := []string{
		"abcd",
		"abCdefAaf",
		"aabcd",
		"строка без_povtareniy",
		"строка С_пОвТАРениямИ", // без конвертации в прописные буквы эта строка будет с уникальными символами
		"",
		" 	",  // вот тут символ пробела и потом таб и можно было бы конечно оптимизировать, но по условию задачи это не нужно
		" \r", // и тут тоже
	}

	// обход тестовых строк
	for _, val := range strs {
		fmt.Printf("%s : %v\n", val, IsUniqueSymbols(val))
	}
}
