// L1.15
// Небольшой фрагмент кода — проблемы и решение
// Рассмотреть следующий код и ответить на вопросы: к каким негативным последствиям он может привести и как это исправить?

// Приведите корректный пример реализации.

// var justString string

// func someFunc() {
//   v := createHugeString(1 &lt;&lt; 10)
//   justString = v[:100]
// }

// func main() {
//   someFunc()
// }
// Вопрос: что происходит с переменной justString?

// Дедлайн — 1 нояб, 02:59

// Решение:

package main

import (
	"fmt"
	"os"
)

var justString string // изначально строка пустая

// этой функции не было. Возникнет ошибка при её вызове.
func createHugeString(length int) string {
	if length <= 0 {
		fmt.Fprintf(os.Stderr, "Ошибка в параметре длины строки")
		os.Exit(1)
	}

	str := make([]byte, 1024) // выделяем под строку область памяти 1024 байта, длину делаем = объёму выделенной памяти

	return string(str) // конвертируем в тип данных string
}

func someFunc() {
	v := createHugeString(1 << 10) // побитово - 1024 байта
	justString = v[:100]           // программа будет работать, первые 100 ячеек v не будут использоваться - они выделены зря. То есть программа потребляет излишние ресурсы памяти.
}

func main() {
	someFunc() // вызов этой функции вызовет панику,
	println(len(justString))
}
