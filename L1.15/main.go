// L1.15
// Небольшой фрагмент кода — проблемы и решение
// Рассмотреть следующий код и ответить на вопросы: к каким негативным последствиям он может привести и как это исправить?

// Приведите корректный пример реализации.

// var justString string

// func someFunc() {
//   v := createHugeString(1 &lt;&lt; 10)
//   justString = v[:100]
// }

// func main() {
//   someFunc()
// }
// Вопрос: что происходит с переменной justString?

// Дедлайн — 1 нояб, 02:59

// Решение:

package main

import (
	"fmt"
	"os"
	"strings"
	// "unsafe"
)

var justString string // изначально строка пустая

// Функции ниже не было в предложенном коде. Возникнет ошибка при её вызове.
// Вообще, существование этой функции сомнительно, потому что не ясно, для каких целей она нужна?
// Тип string в GO нередактируемый. Невозможно изменить символы внутри созданной строки.
func createHugeString(length int) []rune {

	if length <= 0 { // добавили проверку чтоб исключить случаи с паникой
		fmt.Fprintf(os.Stderr, "Ошибка в параметре длины строки")
		os.Exit(1)
	}

	// str := make([]byte, length) // выделяем под строку область памяти 1024 байта,
	// // длину делаем = объёму выделенной памяти. Но это не очень удобно,
	// // так как работает только для однобайтовых символов

	// str := strings.Repeat("й", length) // допустим строка - это полоса с повторяющимся символом определённой длины length.
	// // Но это не очень удобно, так как строку после этого всё равно нельзя редактировать

	str := make([]rune, length) // создаём слайс типа rune, ячейки которого содержат до 4 байт символы

	symbol := '文' // 3-х байтовый иероглиф "вэнь" (китайский), означающий "язык", "письменность".

	println("Заполним слайс символом:", string(symbol), "или код", symbol, "в int32, что соответствует", len(string(symbol)), "байт")

	for value := range str {
		str[value] = symbol // заполняем для проверки много-байтовым символом (можно любым от 1 до 4 байт,
		// так как rune - это обёртка над int32, который содержит в себе 32 бита, то есть 4 байта по 8 бит)
	}

	println("Количество символов(не байт!!!) в слайсе типа []rune =", len(str), "по условию") // количество символов в слайсе, но не байт!!!

	return str // возвращаем можно сказать универсальную редактируемую строку
}

func someFunc() {

	// v := createHugeString(1 << 10) // возвращать из функции тип string заданной длины странно, потому что это нередактируемая строка.
	v := string(createHugeString(1 << 10)) // побитово сместили единицу влево на 10 ячеек при запросе в функцию и получаем строку на 1024 элемента
	println("Количество байт(не символов!!!) в строке v =", len(v), "- Строку мы получили после конвертации возвращенного значения из функции createHugeString")

	justString = v[:100]
	println("Количество байт(не символов!!!) в подстроке v[:100] =", len(justString))
	// Это ссылка на строку-исходник v. Пока программа будет работать,
	// первые 100 байт( c 0 по 99й) будут использоваться,
	// остальные (1024 - 100 = 924 байта) будут просто зарезервированы, но не использованы.
	// То есть программа потребляет излишние ресурсы памяти.
	// Для решения этой проблемы сделаем независимую копию слайса v c 0 по 99й байты:

	justString = strings.Clone(v[:100])
	println("Количество байт(не символов!!!) в копии подстроки v[:100] =", len(justString))
	// однако, это не решает до конца проблему. Если в строке содержатся не однобайтовые символы,
	// например символы русского(двубайтовые), китайского(4 байта) или другие неоднобайтовые символы,
	// результирующая строка будет урезана и мы получим не ожидаемый результат.
	println("Поскольку в строке содержатся не однобайтовые символы, мы получаем не ожидаемый результат:\n", justString,
		"<- обратите внимание на последний символ.\nОн вывелся не до конца, потому что строка содержит 100 байт, а не 100 символов.")
	// Чтобы избежать этой ситуации, необходимо собирать строку типа []rune
	// по длине в нужном количестве символов и потом перед выводом конвертировать её в string:

	editStr := []rune(v) // создаём копию строки v типа []rune
	println("Количество символов(не байт!!!) в копии строки v =", len(editStr), "после создания копии в типе []rune")
	justString = string(editStr[:100]) // создаём копию подстроки editStr длиной 100 символов и конвертируем в string
	println("Количество байт в 100 символах копии подстроки v:", len(justString), "после конвертации из []rune в string")
	println("Ожидаемый результат:\n", justString)

}

func main() {
	someFunc()
}
