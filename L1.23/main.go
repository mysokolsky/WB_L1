// L1.23
// Удаление элемента слайса

// Удалить i-ый элемент из слайса.

// Продемонстрируйте корректное удаление без утечки памяти.

// Подсказка: можно сдвинуть хвост слайса на место удаляемого
// элемента (copy(slice[i:], slice[i+1:])) и уменьшить длину слайса на 1.

// Дедлайн — 5 дек, 02:59

// Решение:

package main

import "fmt"

// import "slices" // только для использования функции Delete

// Функция, в которой происходит удаление элемента.
// На вход подаётся номер элемента и указатель на слайс.
// Если в функцию передавать не указатель, изменения будут
// происходить и с исходным слайсом, но длина length слайса не изменится.
// При передаче указателя так же меняется и длина исходного слайса.
func dropOneIndex(index int, mas *[]int) error {
	if len(*mas) == 0 {
		return fmt.Errorf("error: empty array")
	}
	if index < 0 || index > len(*mas)-1 {
		return fmt.Errorf("error: wrong index number to delete")
	}
	// 1 вариант - append
	// Обязательно нужно сначала обнулить данные последнего элемента
	// Потому что если будет слайс из указателей на структуры например
	// или на другие слайсы и т.п., то после удаления элемента все
	// элементы сдвинутся на один влево, а последний элемент останется
	// вне границ слайса и он будет содержать ссылку на данные в области
	// памяти. Сборщик мусора будет думать, что эта область памяти
	// ещё нужна и не очистит её сам. Возникнет утечка памяти до тех пор,
	// пока слайс не будет удалён или программа не завершит работу.
	tempParam := (*mas)[len(*mas)-1]                   // временная переменная для сохранения последнего элемента перед его занулением
	clear((*mas)[len(*mas)-1:])                        // для версий go 1.21 и выше. Очищает последний элемент, автоматически определяя его тип
	*mas = append((*mas)[:index], (*mas)[index+1:]...) // слайс автоматически меняет длину length меньше на 1 и очистить элемент в конце уже не получится
	(*mas)[len(*mas)-1] = tempParam                    // присваиваем значение последнему элементу

	// // 2 вариант - copy
	// // Работает быстрее append, в основном копирует данные напрямую
	// // чаще всего без дополнительного выделения памяти.
	// // После копирования не уменьшает автоматически параметр length слайса
	// // и при выводе показывает, что в последнем элементе после копирования
	// // ещё остались данные, которые не удалены.
	// copy((*mas)[index:], (*mas)[index+1:]) // копируем элементы на позицию левее, затирая удаляемый элемент
	// clear((*mas)[len(*mas)-1:])            // Очищает последний элемент, автоматически определяя его тип
	// *mas = (*mas)[:len(*mas)-1]            // уменьшаем длину length слайса (но не уменьшаем capacity!!!)

	// // 3 вариант (начиная с go v 1.21 ) - Delete из библиотеки slices
	// // Автоматически зануляет последний элемент.
	// // Самый удобный на данный момент способ.
	// *mas = slices.Delete(*mas, index, index+1)

	return nil
}

func main() {
	var mas = []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	// var mas = []int{1}
	// var mas = []int{}
	fmt.Println("Массив  до  удаления элемента: ", mas)

	indexToDrop := 5
	fmt.Println("Удалим элемент №", indexToDrop)

	if err := dropOneIndex(indexToDrop, &mas); err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println("Массив после удаления элемента:", mas)
}
