// L1.21
// Паттерн «Адаптер»
// Реализовать паттерн проектирования «Адаптер» на любом примере.

// Описание: паттерн Adapter позволяет сконвертировать интерфейс
// одного класса в интерфейс другого, который ожидает клиент.

// Продемонстрируйте на простом примере в Go: у вас есть существующий
// интерфейс (или структура) и другой, несовместимый по интерфейсу
// потребитель — напишите адаптер, который реализует нужный
// интерфейс и делегирует вызовы к встроенному объекту.

// Поясните применимость паттерна, его плюсы и минусы,
// а также приведите реальные примеры использования.

// Дедлайн — 25 нояб, 02:59

// Решение:

// паттерн "Адаптер" - это надстройка над существующим кодом.
// Задача адаптера - получить необходимого формата данные из
// имеющегося исходного кода с некоторой адаптацией под
// конкретную текущую задачу, не меняя исходный код.

// В классическом исполнении адаптер имеет вид:

// // Target — интерфейс, который ожидает клиент
// type Target interface{
// 	Method1(...)
// 	...
// 	MethodX(...)
// 	}

// // Adaptee — существующие несовместимые классы (типы)
// type Adaptee1 struct{...}
// ...
// type AdapteeN struct{...}

// // Adapter — преобразует Adaptee → Target
// type Adapter struct{
// 	pointer1 *Adaptee1
// 	pointer2 *Adaptee2
// 	...
// 	pointerN *AdapteeN
// 	}

// // Adapter реализует методы Target
// func (a *Adapter) Method1(...) {
// 	a.pointer1.SomeMethod(...)
// 	}
// ...
// func (a *Adapter) MethodX(...) {
//     a.pointer2.AnotherMethod(...)
// }

// // Клиент работает только с Target, не зная про Adaptee
// func ClientResponse(t Target) {
// 	t.Method1(...)
// 	...
// 	t.MethodX(...)
// 	}

// // Создаём Adaptee → оборачиваем в Adapter → отдаём ClientResponse
// func main() {
// 	obj1 := &Adaptee1{...}
// 	...
// 	objN := &AdapteeN{...}

// 	adapter := &Adapter{
// 		pointer1: obj1,
// 		...
// 		pointerN: objN}

// 	ClientResponse(adapter) // реализация поставленной задачи
// }

// Плюсы использования паттерна Адаптер:
//
// 1. универсальность. Применяется в любых ситуациях.
// 2. не меняет исходный код
// 3. позволяет сделать универсальную надстройку и оградить её пользователя от вникания в код исходников
//
// Минусы:
// 1. при реализации большого количества адаптеров усложняет читабельность кода
// 2. зависит от исходного кода. Если он изменится, то адаптер тоже придётся переписывать

// Простой пример использования:
// Допустим, у нас есть структура Bird, у которой есть методы eat, sleep и fly.
// Эта структура полностью реализует интерфейс BeBird -
// весь набор методов, объявленный в этом интерфейсе.
// И у нас есть некий интерфейс BeDog, которому должен удовлетворять наш вывод программы.
// В интерфейсе BeDog объявлены методы, которые частично совпадают с методами интерфейса
// BeBird, но есть и несоответствие. При этом определены в Dog только часть методов интерфейса BeDog.
// Таким образом чтобы реализовать вывод в формате интерфейса
// BeDog, мы не можем просто унаследовать структуры Bird и Dog. Нам придётся написать структуру
// Adapter, которую мы будем использовать как промежуточное звено, в которой пропишем ссылки
// на Bird и Dog, чтобы можно было через ссылки обращаться к одинаковым методам структуры Bird и уникальным Dog.
// При необходимости, мы так же для Adapter можем определить свои уникальные методы

package main

// Adaptee interface
type BeBird interface {
	eat()
	sleep()
	fly()
}

// Adaptee
type Bird struct {
}

func (b *Bird) eat() {
	println("Покушали")
}

func (b *Bird) fly() {
	println("Полетали")
}

func (b *Bird) sleep() {
	println("Поспали")
}

type Dog struct{}

func (d *Dog) gaf() {
	println("Гаф! Гаф!")
}

// Target
type BeDog interface {
	eat()
	sleep()
	gaf()
}

// Adapter
type Adapter struct {
	bird *Bird // здесь можно было бы написать без именнованного поля - просто *Bird.
	// И тогда нам не пришлось бы определять отдельно методы для Adapter,
	// поскольку они автоматически переадресовывались бы при вызове из Bird,
	// но в этом случае это не являлось бы непосредственно реализацией паттерна "Адаптер",
	// а просто композицией с наследованием методов и полей Bird.
	// И ещё, если бы у нас были одинаковые имена полей в Bird и Dog
	// и мы к ним обращались бы в программе без указания типа структуры (Bird или Dog),
	// то это вызвало бы ошибку неопределённого поведения программы.
	dog *Dog // актуально то же что и для Bird
}

// самая важная часть. Переопределение методов Adaptee для удовлетворения выводу Target
func (a *Adapter) eat() {
	a.bird.eat()
}

func (a *Adapter) sleep() {
	a.bird.sleep()
}

func (a *Adapter) gaf() {
	a.dog.gaf()
}

// вызов методов Target
// пользователю не важно, что 'под капотом' в Target
func ClientResponse(bd BeDog) {
	bd.eat()
	bd.sleep()
	bd.gaf()
}

func main() {

	b := &Bird{}
	d := &Dog{}
	adapter := &Adapter{bird: b, dog: d}
	ClientResponse(adapter)
}
